#!/usr/bin/perl

require 'stringdata.pm';

use Data::Dumper;

if ( $#ARGV == 0 ) {
	die "no classes to snapshot\n";
}
elsif ( $#ARGV == -1 ) {
	die "Usage: aj_gen2 <outfile> <class to trace> ..";
}

open OUTFILE, ">", $ARGV[ 0 ] or die "Could not open output file '" . $ARGV[ 0 ] . "' for writing\n";

open INVITE, "<", "../com/invite/core/InsertTest.java.template" or die "Cannot find required file InsertTest.java.template\n";

#make these set-able via switches
my $default_obj_vec_size = 50;
my $config_file = "/home/del/Desktop/thesis/tracing/com/invite/core/config";
my $max_chain_len = 30;

my $class_info = get_class_info();

print OUTFILE "package com.invite.core;\n\n";
print OUTFILE "import com.invite.changetracking.*;\n";

# get rid of this and figure out a permantent system for putting instrumented code here
print OUTFILE "import com.invite.drivers.*;\n";



# -- THE BELOW WILL BE IMPLEMENTED WHEN CLASSES ARE STORED AS FULLY-QUALIFIED
#    (also get info for methods accessing members directly)
#print import statements for all instrumented classes
#for my $class ( keys %$class_info ) {
#	print OUTFILE "import $class.*;\n";
#}


while ( <INVITE> ) {
	#s/configFile = ".*"/configFile = "$config_file"/;
	s/Object around(): demoExecs()/Object around(): demoExecs() && notInvite()/;
	s/static final int MAX_CHAIN_LEN  .*/static final int MAX_CHAIN_LEN = $max_chain_len;/;

	print OUTFILE $_;
	
	if ( /static final void println/ ) {
		print OUTFILE sprintf(
				     	$Stringdata::general_use,
					$default_obj_vec_size
				      );
		print_tracer_aspects( $class_info );
	}
	
	if ( /\/\*\* insert failure reporting here \*\// ) {	       	
		insert_tracing_logic();
	}
}

sub get_class_info {
	my $i;
        my $classes = {
		IntFields => { field1 => 'INT_TYPE', field3 => 'INT_TYPE', testBool => 'BOOLEAN_TYPE' },
	};
	
	return $classes;
}

#call with a hash of data on what to track as outlined in a previous comment
sub print_tracer_aspects {
	my $class_info = shift;

	foreach my $class ( keys %$class_info ) {
		print OUTFILE "/********   INSTRUMENTATION FOR CLASS $class   ********/\n\n";
		print OUTFILE "\t// Fields for class $class\n";
		print OUTFILE sprintf(
				      	$Stringdata::fields_per_class,
				      	$class,
					$class,
					$class,
					$class,
					$class
				      );

		print OUTFILE "\t// Pointcuts for class $class\n";
		print OUTFILE sprintf(
				      	$Stringdata::pointcuts_per_class,
					$class,
					$class,
					$class,
					$class
				      );

		my @members;
		while ( my ( $field, $type ) = each ( %{ $class_info->{$class} } ) ) {
			push @members, sprintf(
					       	$Stringdata::field_checks_per_class,
						$field,
						$field,
						$field,
						$field,
						$field,
						$type
					       );
		}

		my $member_equality_checks =  join( "\n", @members );

		print OUTFILE "\n\t// Joinpoints for class $class\n";
		print OUTFILE sprintf(
				      	$Stringdata::joinpoints_per_class,
					$class,
					$class,
					$class,
					$class,
					$class,
					$class,
					$class,
					$class,
					$class,
					$class,
					$member_equality_checks
				      );
	}
}

sub insert_tracing_logic {
	my $tracing_logic = "\t\t/** Huzzah, tracing logic abound! **/\n";
	print OUTFILE $tracing_logic;
}

